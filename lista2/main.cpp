#include <sstream>
#include <iostream>
#include <iomanip>
#include <array>
#include <vector>
#include <thread>
#include <cstdint>
#include <cassert>
#include <memory>
#include <iterator>
#include <stdexcept>

#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/err.h>

#include "utils.hpp"
#include "CipherCtxHandler.hpp"
#include "Cracker.hpp"

namespace mp = boost::multiprecision;

void task1()
{
    ByteBuffer ciphertext {
        0b01001111, 0b10001010, 0b01001111, 0b11000111,
        0b00101011, 0b10100010, 0b00111111, 0b00111110,
        0b01011010, 0b00001011, 0b00101000, 0b10111011,
        0b01001110, 0b10001110, 0b11011010, 0b01010000,
        0b10001011, 0b00011000, 0b11110111, 0b00101000,
        0b00100001, 0b00001011, 0b00101100, 0b01100100,
        0b11110000, 0b10100011, 0b00111010, 0b00111011,
        0b00011100, 0b01110111, 0b11011010, 0b11111011,
        0b11110010, 0b11101010, 0b10010011, 0b11100001,
        0b10010100, 0b10000000, 0b10001101, 0b11101001,
        0b11110111, 0b11010011, 0b00001100, 0b00110110,
        0b01000011, 0b11100100, 0b01110010, 0b10110000,
        0b01011010, 0b00101010, 0b01111010, 0b11010001,
        0b10011111, 0b00100101, 0b11000010, 0b01110100,
        0b00101111, 0b11101111, 0b11100111, 0b10010001,
        0b00111100, 0b11111011, 0b00000100, 0b11011001,
        0b01001110, 0b01100001, 0b11010110, 0b00001110,
        0b01010001, 0b11000000, 0b01111111, 0b10111000,
        0b10000011, 0b01011010, 0b11011010, 0b11100010,
        0b11011100, 0b01111011, 0b10101110, 0b11110110,
        0b00110001, 0b00100001, 0b10111001, 0b01000010,
        0b01011101, 0b01010111, 0b01010000, 0b01010010,
        0b00001000, 0b10110111, 0b01010011, 0b10111001,
        0b01100000, 0b00100101, 0b00100000, 0b01010100,
        0b00100010, 0b00110100, 0b10111101, 0b01010000,
        0b10001101, 0b11101001, 0b10000000, 0b00011110,
        0b10110010, 0b11011111, 0b10000001, 0b10010001,
        0b10101010, 0b10110100, 0b01101101, 0b00000000,
        0b10101011, 0b11011010, 0b11001010, 0b00011100,
        0b11110011, 0b11001100, 0b10110000, 0b10110011,
        0b00110011, 0b11111110, 0b01110000, 0b00111000,
        0b00010001, 0b10111111, 0b01100111, 0b11011101,
        0b01001010, 0b01000000, 0b11000111, 0b01011101,
        0b10111101, 0b01101010, 0b11010111, 0b00111010,
        0b00100101, 0b00101110, 0b00001011, 0b01001010,
        0b10100101, 0b10111000, 0b01010000, 0b10010110,
        0b10000111, 0b10001000, 0b10011100, 0b00111011,
        0b11011001, 0b11001100, 0b00100111, 0b11010000,
        0b11110111, 0b10010001, 0b01100001, 0b10101110,
        0b01001010, 0b01001100, 0b11100011, 0b01000100
    };
    Cracker c(
      64,
      "aa56b18fb569d82af34a55ce142c10ec82c0774929e0d7bc459f2102",
      {0xc5, 0xb7, 0x1a, 0x78, 0xa6, 0xf8, 0x84, 0xd8, 0xa4, 0x33, 0x1a, 0xfe, 0xf1, 0x6c, 0x5c, 0x0b});
    auto keys = c.crack(ciphertext);
    for(auto& k : keys)
    {
        std::cout << hex(k) << std::endl;
    }
}

int main()
{
    task1();
}
